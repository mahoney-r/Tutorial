---
title: 'Introduction To R: Part Two - Solutions'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Part One

1. Create a vector of the first 16 prime numbers.


```{R}
#library
library(primes)

#create vector
prime_nos<-generate_primes(min=0, max=55)
```


2. Use this vector to create a 4x4 matrix called ```my_mat``` using default parameters.


```{R}
#create matrix
my_mat<-matrix(prime_nos,4,4)
my_mat
```


3. Add the numbers 1-4 as a new row to the matrix.


```{r}
#add seq 1-4 to matrix
my_mat<-rbind(my_mat,seq(1:4))
my_mat
```


4. Replace the entry at the position 2,3 with 3.


```{R}
#change entry
my_mat[2,3]=3
my_mat
```



5. Write a loop that checks if the entries of the fifth row are even. If they are print "You found me", otherwise print "Try again"


```{R}
#for entries of row five of my_mat
for (entry in my_mat[5,]){
  # if remainder when entry/2 is 0 --> even
  ifelse(entry%%2==0, print("You found me"),print("Try again"))
}    
```

6. Remove the third row.


```{r}
#remove row 3
my_mat<-my_mat[-3,]
```


7. Print out the final matrix.


```{r}
#print mat
print(my_mat)

```



## Part Two
You have been asked to analyse the results of a differential expression analysis. You have been supplied with ```results.txt```, the output of this analysis. This includes:

- baseMean: The average of the normalised counts per gene across all samples
- log2FoldChange: Gives an idea of change in expression due to a test condition with respect to control
- lfcSE: Standard error of log2 fold change
- pval: P value, the result of a hypothesis test to test whether the change in expression can be attributed to the test condition
- padj: P value adjusted for multiple testing


1. Read in the file and assign the variable name  ```de```.

```{r}
##read in file
#watch sep!
de<-read.table("~/results.txt", sep=";", header=T)
```

2. Head the first 10 rows.

```{r}
## head first 10
head(de,10)

```

3. Tail the last 8 rows of columns 2 to 3.

```{r}
##last 8, col 2:3
tail(de[,2:3],8)
```

4. Identify the number of columns and rows.

```{r}
dim(de)
```

5. Change the name of the third column to "L2FC".

```{r}
##abbreviate col 3 name
colnames(de)[3]="L2FC"
```


6. Extract columns 1:3, rows 1:100 and save as ```sliced_df```. Head the result.

```{R}
#slice up the df
sliced_df<-de[1:100,1:3]
```


7. Are there any duplicates? How many? If their are duplicates, remove them, then set the first column as rownames and remove the first column. (Continue with dataframe from 5. ```de``` NOT ```sliced_df```)

```{r}
##check for duplicate
dim(de[duplicated(de),])

#or
length(which(duplicated(de)))

##remove duplicate
de_rmdup <- de[!duplicated(de), ]

##double check
length(which(duplicated(de_rmdup)))

#rownames
rownames(de_rmdup)=de_rmdup[,1]
de_rmdup$Gene=NULL

```


8. Are there any missing values? If so, remove rows containing them.


```{r}
##check for missing
## >0 -> na's present 
length(is.na(de_rmdup))
#remove na
de_clean<-na.omit(de_rmdup)
```



9. The information regarding the following gene was mistakenly left out of the dataset, correct this mistake.
   - ENSMUSG00000039287	570.805924	-0.4648999	0.09045180	2.751007e-07	6.393878e-04

   
```{r}
##add row
de_clean<-rbind(de_clean, ENSMUSG00000039287=c(570.805924,	-0.4648999,	0.09045180,	2.751007e-07,	6.393878e-04))
```

10. The Wald statistic is generated by dividing log2 fold change by lfcSE and is used to generate the p value. It is missing from this dataset. Add a column that contains a Wald Statistic for each gene and call it ```stat```.


```{r}
##stat col
de_clean$stat=de_clean$L2FC/de_clean$lfcSE
```


11. Using both (a) summary and (b) a for loop, find the mean of each column storing the loop output in a vector.


```{r}
##means with summary
summary(de_clean)

#means with loop
mean_vec<-c()
for (coln in 1:length(colnames(de_clean)) ) {
  mn<-mean(de_clean[,coln])
  mean_vec<-c(mean_vec,mn)
}

```



12. Print the results of 11 (b).

```{r}
#mean vector
mean_vec
```



13.How many genes are < 0.05 in both the pval and padj columns?

```{r}
###significant genes
nrow(subset(de_clean, de_clean$pvalue<0.05 & de_clean$padj<0.05))
```



14. Use a for loop and an if else statement to fill a new column called ```Significance```. If the padj column is < 0.05 the Significance value should be "Sig" otherwise it should be "Not Sig".


```{r}
# for each gene
for (i in 1:length(de_clean$pvalue)) {
  #if padj < 0.05
  if (de_clean$padj[i] < 0.05 ) {
    #new col is sig
    de_clean$Signficance[i]="Sig"
  }
  #otherwise 
  else{
    de_clean$Signficance[i]="Not Sig"
  }
}    

```

15. There is a cleaner and easier way to do this. Repeat the exercise in 13 without loops or ifelse, except this time add values to the new column ```Expression```. If the value in the ```L2FC``` column is > 1 or < -1, the corresponding value in ```Expression``` should be "big_change", otherwise it should be "little_change". Hint: Read through section 4.1 - 4.5 of the tutorial for inspiration!

```{r}
# using []
#create col
#set all to little
de_clean$Expression="little_change"
#when l2fc is > 1 or < -1, change to big
de_clean$Expression[abs(de_clean$L2FC)>1]="big_change"
```

16. Find the dimensions of the dataframe that satisfies the following conditions:
    pvalue < 0.05 
    OR
    L2FC > 1
    
```{r}
##rows and columns f subset
dim(de_clean[de_clean$pvalue<0.05 | de_clean$L2FC>1,])

```



17. Replace ENSMUSG in the rownames with MOUSE.

```{r}
##change rowname prefix
rownames(de_clean)<-gsub("ENSMUSG","MOUSE", rownames(de_clean))
```

18. Find the row numbers whose rownames have the following pattern: "126".

```{r}
##pattern match
grep("126", rownames(de_clean))
```

19. Select all genes whose expression values < -1 or > 1 and whose adjusted p value is < 0.05. Call the new dataframe ```interesting_res```.

```{r}
#filter using p val and lfc
interesting_res=subset(de_clean,abs(de_clean$L2FC)>1 & de_clean$padj<0.05)
```


  
20. Order by adjusted p value in increasing order of signifcance. Call the new dataframe ```interesting_res_ordered```.


```{r}
#order by p value
interesting_res_ordered <- interesting_res[order(interesting_res$padj), ]
```


21. Write out the final dataset to a comma separated file called ```DE_RESULTS.csv```. See if you can read it back in without issues.

```{r}
write.table(interesting_res_ordered, "DE_RESULTS.csv", col.names = T)
```

1. Love, M.I., Huber, W., Anders, S. Moderated estimation of fold change and dispersion for RNA-seq data with DESeq2 Genome Biology 15(12):550 (2014)




